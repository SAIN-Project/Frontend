import { EventEmitter, Directive, ElementRef, Output, Injectable, NgZone, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, TemplateRef, ViewContainerRef, Component, ChangeDetectionStrategy, forwardRef, Input, ViewChild, NgModule } from '@angular/core';
import { ResizeSensor } from 'css-element-queries';
import { BehaviorSubject, Subject } from 'rxjs';
import { takeUntil, filter, take } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/resized-event.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';

const _c0 = ["editor"];
const _c1 = ["diffEditor"];
class ResizedEvent {
    /**
     * @param {?} element
     * @param {?} newWidth
     * @param {?} newHeight
     * @param {?} oldWidth
     * @param {?} oldHeight
     */
    constructor(element, newWidth, newHeight, oldWidth, oldHeight) {
        this.element = element;
        this.newWidth = newWidth;
        this.newHeight = newHeight;
        this.oldWidth = oldWidth;
        this.oldHeight = oldHeight;
    }
}
if (false) {
    /** @type {?} */
    ResizedEvent.prototype.element;
    /** @type {?} */
    ResizedEvent.prototype.newWidth;
    /** @type {?} */
    ResizedEvent.prototype.newHeight;
    /** @type {?} */
    ResizedEvent.prototype.oldWidth;
    /** @type {?} */
    ResizedEvent.prototype.oldHeight;
}
class ResizedDirective {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.resized = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.resizeEvent = new ResizeSensor(this.element.nativeElement, (/**
         * @param {?} x
         * @return {?}
         */
        x => this.onResized()));
        this.onResized();
    }
    /**
     * @private
     * @return {?}
     */
    onResized() {
        /** @type {?} */
        const newWidth = this.element.nativeElement.clientWidth;
        /** @type {?} */
        const newHeight = this.element.nativeElement.clientHeight;
        if (newWidth === this.oldWidth && newHeight === this.oldHeight) {
            return;
        }
        /** @type {?} */
        const event = new ResizedEvent(this.element, newWidth, newHeight, this.oldWidth, this.oldHeight);
        this.oldWidth = this.element.nativeElement.clientWidth;
        this.oldHeight = this.element.nativeElement.clientHeight;
        this.resized.next(event);
    }
}
ResizedDirective.ɵfac = function ResizedDirective_Factory(t) { return new (t || ResizedDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ResizedDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ResizedDirective, selectors: [["", "materiaResized", ""]], outputs: { resized: "resized" }, exportAs: ["materiaResized"] });
/** @nocollapse */
ResizedDirective.ctorParameters = () => [
    { type: ElementRef }
];
ResizedDirective.propDecorators = {
    resized: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ResizedDirective, [{
        type: Directive,
        args: [{
                selector: '[materiaResized]',
                exportAs: 'materiaResized'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { resized: [{
            type: Output
        }] }); })();
if (false) {
    /** @type {?} */
    ResizedDirective.prototype.resized;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.oldWidth;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.oldHeight;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.resizeEvent;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.element;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/interfaces/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/// <reference path="monaco.d.ts" />
/** @type {?} */
const MONACO_PATH = 'MONACO_PATH';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/monaco-editor-loader.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MonacoEditorLoaderService {
    /**
     * @param {?} ngZone
     * @param {?} monacoPathConfig
     */
    constructor(ngZone, monacoPathConfig) {
        this.ngZone = ngZone;
        this.monacoPathConfig = monacoPathConfig;
        this.isMonacoLoaded$ = new BehaviorSubject(false);
        this._monacoPath = 'assets/monaco-editor/min/vs';
        if (((/** @type {?} */ (window))).monacoEditorAlreadyInitialized) {
            ngZone.run((/**
             * @return {?}
             */
            () => this.isMonacoLoaded$.next(true)));
            return;
        }
        ((/** @type {?} */ (window))).monacoEditorAlreadyInitialized = true;
        if (this.monacoPathConfig) {
            this.monacoPath = this.monacoPathConfig;
        }
        this.loadMonaco();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set monacoPath(value) {
        if (value) {
            this._monacoPath = value;
        }
    }
    /**
     * @return {?}
     */
    loadMonaco() {
        /** @type {?} */
        const onGotAmdLoader = (/**
         * @return {?}
         */
        () => {
            // Load monaco
            ((/** @type {?} */ (window))).amdRequire = ((/** @type {?} */ (window))).require;
            if (this.nodeRequire) {
                ((/** @type {?} */ (window))).require = this.nodeRequire;
            }
            ((/** @type {?} */ (window))).amdRequire.config({ paths: { 'vs': this._monacoPath } });
            ((/** @type {?} */ (window))).amdRequire(['vs/editor/editor.main'], (/**
             * @return {?}
             */
            () => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.isMonacoLoaded$.next(true)));
            }));
        });
        /** @type {?} */
        let loaderScript = null;
        // Load AMD loader if necessary
        if (!((/** @type {?} */ (window))).require && !((/** @type {?} */ (window))).amdRequire) {
            loaderScript = document.createElement('script');
            loaderScript.type = 'text/javascript';
            loaderScript.src = `${this._monacoPath}/loader.js`;
            loaderScript.addEventListener('load', onGotAmdLoader);
            document.body.appendChild(loaderScript);
        }
        else if (!((/** @type {?} */ (window))).amdRequire) {
            this.addElectronFixScripts();
            this.nodeRequire = ((/** @type {?} */ (window))).require;
            loaderScript = document.createElement('script');
            loaderScript.type = 'text/javascript';
            loaderScript.src = `${this._monacoPath}/loader.js`;
            loaderScript.addEventListener('load', onGotAmdLoader);
            document.body.appendChild(loaderScript);
        }
        else {
            onGotAmdLoader();
        }
    }
    /**
     * @return {?}
     */
    addElectronFixScripts() {
        /** @type {?} */
        const electronFixScript = document.createElement('script');
        // workaround monaco-css not understanding the environment
        /** @type {?} */
        const inlineScript = document.createTextNode('self.module = undefined;');
        // workaround monaco-typescript not understanding the environment
        /** @type {?} */
        const inlineScript2 = document.createTextNode('self.process.browser = true;');
        electronFixScript.appendChild(inlineScript);
        electronFixScript.appendChild(inlineScript2);
        document.body.appendChild(electronFixScript);
    }
}
MonacoEditorLoaderService.ɵfac = function MonacoEditorLoaderService_Factory(t) { return new (t || MonacoEditorLoaderService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(MONACO_PATH, 8)); };
MonacoEditorLoaderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: MonacoEditorLoaderService, factory: MonacoEditorLoaderService.ɵfac, providedIn: 'root' });
/** @nocollapse */
MonacoEditorLoaderService.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MONACO_PATH,] }] }
];
/** @nocollapse */ MonacoEditorLoaderService.ngInjectableDef = ɵɵdefineInjectable({ factory: function MonacoEditorLoaderService_Factory() { return new MonacoEditorLoaderService(ɵɵinject(NgZone), ɵɵinject("MONACO_PATH", 8)); }, token: MonacoEditorLoaderService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MonacoEditorLoaderService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MONACO_PATH]
            }] }]; }, null); })();
if (false) {
    /** @type {?} */
    MonacoEditorLoaderService.prototype.nodeRequire;
    /** @type {?} */
    MonacoEditorLoaderService.prototype.isMonacoLoaded$;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderService.prototype._monacoPath;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderService.prototype.ngZone;
    /** @type {?} */
    MonacoEditorLoaderService.prototype.monacoPathConfig;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/monaco-editor-loader.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MonacoEditorLoaderDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     * @param {?} monacoEditorLoaderService
     */
    constructor(templateRef, viewContainer, monacoEditorLoaderService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.monacoEditorLoaderService = monacoEditorLoaderService;
        this.isMonacoLoaded$ = this.monacoEditorLoaderService.isMonacoLoaded$.asObservable();
        this.destroyed$ = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isMonacoLoaded$.pipe(takeUntil(this.destroyed$)).subscribe((/**
         * @param {?} loaded
         * @return {?}
         */
        (loaded) => {
            if (!loaded) {
                return this.viewContainer.clear();
            }
            this.viewContainer.createEmbeddedView(this.templateRef);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
}
MonacoEditorLoaderDirective.ɵfac = function MonacoEditorLoaderDirective_Factory(t) { return new (t || MonacoEditorLoaderDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MonacoEditorLoaderService)); };
MonacoEditorLoaderDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MonacoEditorLoaderDirective, selectors: [["", "ngxLoadMonacoEditor", ""]] });
/** @nocollapse */
MonacoEditorLoaderDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: MonacoEditorLoaderService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MonacoEditorLoaderDirective, [{
        type: Directive,
        args: [{ selector: '[ngxLoadMonacoEditor]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }, { type: MonacoEditorLoaderService }]; }, null); })();
if (false) {
    /** @type {?} */
    MonacoEditorLoaderDirective.prototype.isMonacoLoaded$;
    /** @type {?} */
    MonacoEditorLoaderDirective.prototype.destroyed$;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderDirective.prototype.monacoEditorLoaderService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/monaco-editor/monaco-editor.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MonacoEditorComponent {
    /**
     * @param {?} monacoLoader
     */
    constructor(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
        this.propagateChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.container = this.editorContent.nativeElement;
        this.monacoLoader.isMonacoLoaded$.pipe(filter((/**
         * @param {?} isLoaded
         * @return {?}
         */
        isLoaded => isLoaded)), take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            this.initMonaco();
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.editor && changes.options && !changes.options.firstChange) {
            if (changes.options.previousValue.language !== changes.options.currentValue.language) {
                monaco.editor.setModelLanguage(this.editor.getModel(), this.options && this.options.language ? this.options.language : 'text');
            }
            if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                monaco.editor.setTheme(changes.options.currentValue.theme);
            }
            this.editor.updateOptions(changes.options.currentValue);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
        if (this.editor && value) {
            this.editor.setValue(value);
        }
        else if (this.editor) {
            this.editor.setValue('');
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @return {?}
     */
    validate() {
        return (!this.parseError) ? null : {
            parseError: {
                valid: false,
            }
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onErrorStatusChange = fn;
    }
    /**
     * @private
     * @return {?}
     */
    initMonaco() {
        /** @type {?} */
        let opts = {
            value: [this.value].join('\n'),
            language: 'text',
            automaticLayout: true,
            scrollBeyondLastLine: false,
            theme: 'vc'
        };
        if (this.options) {
            opts = Object.assign({}, opts, this.options);
        }
        this.editor = monaco.editor.create(this.container, opts);
        this.editor.layout();
        this.editor.onDidChangeModelContent((/**
         * @return {?}
         */
        () => {
            this.propagateChange(this.editor.getValue());
        }));
        this.editor.onDidChangeModelDecorations((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const pastParseError = this.parseError;
            if (monaco.editor.getModelMarkers({}).map((/**
             * @param {?} m
             * @return {?}
             */
            m => m.message)).join(', ')) {
                this.parseError = true;
            }
            else {
                this.parseError = false;
            }
            if (pastParseError !== this.parseError) {
                this.onErrorStatusChange();
            }
        }));
        this.editor.onDidBlurEditorText((/**
         * @return {?}
         */
        () => {
            this.onTouched();
        }));
        this.init.emit(this.editor);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResized(event) {
        if (this.editor) {
            this.editor.layout({
                width: event.newWidth,
                height: event.newHeight
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.editor) {
            this.editor.dispose();
        }
    }
}
MonacoEditorComponent.ɵfac = function MonacoEditorComponent_Factory(t) { return new (t || MonacoEditorComponent)(ɵngcc0.ɵɵdirectiveInject(MonacoEditorLoaderService)); };
MonacoEditorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MonacoEditorComponent, selectors: [["ngx-monaco-editor"]], viewQuery: function MonacoEditorComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editorContent = _t.first);
    } }, inputs: { options: "options" }, outputs: { init: "init" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(( /**
                 * @return {?}
                 */() => MonacoEditorComponent)),
                multi: true
            },
            {
                provide: NG_VALIDATORS,
                useExisting: forwardRef(( /**
                 * @return {?}
                 */() => MonacoEditorComponent)),
                multi: true
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 4, consts: [["materiaResized", "", "fxFlex", "", 1, "editor-container", 3, "resized"], ["container", ""], [1, "wrapper"], [1, "monaco-editor", 2, "min-width", "0"], ["editor", ""]], template: function MonacoEditorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("resized", function MonacoEditorComponent_Template_div_resized_0_listener($event) { return ctx.onResized($event); });
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelement(3, "div", 3, 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵstyleProp("width", _r0.offsetWidth, "px")("height", _r0.offsetHeight, "px");
    } }, directives: [ResizedDirective], styles: ["[_nghost-%COMP%] {\n\tflex: 1;\n\tbox-sizing: border-box;\n\tflex-direction: column;\n\tdisplay: flex;\n\toverflow: hidden;\n\tmax-width: 100%;\n\tmin-wdith: 0;\n}\n.wrapper[_ngcontent-%COMP%] {\n\twidth: 0px; height: 0px;\n}\n.editor-container[_ngcontent-%COMP%] {\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n\tposition: relative;\n\tmin-width: 0;\n\tdisplay: table;\n\twidth: 100%;\n\theight: 100%;\n}"], changeDetection: 0 });
/** @nocollapse */
MonacoEditorComponent.ctorParameters = () => [
    { type: MonacoEditorLoaderService }
];
MonacoEditorComponent.propDecorators = {
    options: [{ type: Input }],
    init: [{ type: Output }],
    editorContent: [{ type: ViewChild, args: ['editor', { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MonacoEditorComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-monaco-editor',
                template: `<div #container materiaResized (resized)="onResized($event)" class="editor-container" fxFlex>
	<div class="wrapper">
		<div
			#editor
			class="monaco-editor"
			[style.width.px]="container.offsetWidth"
			[style.height.px]="container.offsetHeight" style="min-width: 0;"
		></div>
	</div>
</div>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(( /**
                         * @return {?}
                         */() => MonacoEditorComponent)),
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(( /**
                         * @return {?}
                         */() => MonacoEditorComponent)),
                        multi: true
                    }
                ],
                styles: [`:host {
	flex: 1;
	box-sizing: border-box;
	flex-direction: column;
	display: flex;
	overflow: hidden;
	max-width: 100%;
	min-wdith: 0;
}
.wrapper {
	width: 0px; height: 0px;
}
.editor-container {
	text-overflow: ellipsis;
	overflow: hidden;
	position: relative;
	min-width: 0;
	display: table;
	width: 100%;
	height: 100%;
}`]
            }]
    }], function () { return [{ type: MonacoEditorLoaderService }]; }, { init: [{
            type: Output
        }], options: [{
            type: Input
        }], editorContent: [{
            type: ViewChild,
            args: ['editor', { static: true }]
        }] }); })();
if (false) {
    /** @type {?} */
    MonacoEditorComponent.prototype.options;
    /** @type {?} */
    MonacoEditorComponent.prototype.init;
    /** @type {?} */
    MonacoEditorComponent.prototype.editorContent;
    /** @type {?} */
    MonacoEditorComponent.prototype.container;
    /** @type {?} */
    MonacoEditorComponent.prototype.editor;
    /** @type {?} */
    MonacoEditorComponent.prototype.value;
    /** @type {?} */
    MonacoEditorComponent.prototype.parseError;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.onTouched;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.onErrorStatusChange;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.propagateChange;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.monacoLoader;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/monaco-diff-editor/monaco-diff-editor.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MonacoDiffEditorComponent {
    /**
     * @param {?} monacoLoader
     */
    constructor(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.container = this.editorContent.nativeElement;
        this.monacoLoader.isMonacoLoaded$.pipe(filter((/**
         * @param {?} isLoaded
         * @return {?}
         */
        isLoaded => isLoaded)), take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            this.initMonaco();
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.editor && ((changes.code && !changes.code.firstChange) || (changes.modified && !changes.modified.firstChange))) {
            /** @type {?} */
            const modified = monaco.editor.createModel(this.modified);
            /** @type {?} */
            const original = monaco.editor.createModel(this.original);
            this.editor.setModel({
                original,
                modified
            });
        }
        if (this.editor &&
            changes.options &&
            !changes.options.firstChange) {
            if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                monaco.editor.setTheme(changes.options.currentValue.theme);
            }
            this.editor.updateOptions(changes.options.currentValue);
        }
    }
    /**
     * @private
     * @return {?}
     */
    initMonaco() {
        /** @type {?} */
        let opts = {
            readOnly: true,
            theme: 'vc'
        };
        if (this.options) {
            opts = Object.assign({}, opts, this.options);
        }
        this.editor = monaco.editor.createDiffEditor(this.container, opts);
        /** @type {?} */
        const original = monaco.editor.createModel(this.original);
        /** @type {?} */
        const modified = monaco.editor.createModel(this.modified);
        this.editor.setModel({
            original,
            modified
        });
        this.editor.layout();
        this.init.emit(this.editor);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResized(event) {
        if (this.editor) {
            this.editor.layout({
                width: event.newWidth,
                height: event.newHeight
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.editor) {
            this.editor.dispose();
        }
    }
}
MonacoDiffEditorComponent.ɵfac = function MonacoDiffEditorComponent_Factory(t) { return new (t || MonacoDiffEditorComponent)(ɵngcc0.ɵɵdirectiveInject(MonacoEditorLoaderService)); };
MonacoDiffEditorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MonacoDiffEditorComponent, selectors: [["ngx-monaco-diff-editor"]], viewQuery: function MonacoDiffEditorComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editorContent = _t.first);
    } }, inputs: { original: "original", modified: "modified", options: "options" }, outputs: { init: "init" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 4, consts: [["materiaResized", "", "fxFlex", "", 1, "editor-container", 3, "resized"], ["container", ""], [1, "wrapper"], [1, "monaco-editor", 2, "min-width", "0"], ["diffEditor", ""]], template: function MonacoDiffEditorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("resized", function MonacoDiffEditorComponent_Template_div_resized_0_listener($event) { return ctx.onResized($event); });
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelement(3, "div", 3, 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵstyleProp("width", _r0.offsetWidth, "px")("height", _r0.offsetHeight, "px");
    } }, directives: [ResizedDirective], styles: ["[_nghost-%COMP%] {\nflex: 1;\nbox-sizing: border-box;\nflex-direction: column;\ndisplay: flex;\noverflow: hidden;\nmax-width: 100%;\nmin-wdith: 0;\n}\n.wrapper[_ngcontent-%COMP%] {\nwidth: 0px; height: 0px;\n}\n.editor-container[_ngcontent-%COMP%] {\ntext-overflow: ellipsis;\noverflow: hidden;\nposition: relative;\nmin-width: 0;\ndisplay: table;\nwidth: 100%;\nheight: 100%;\n}"], changeDetection: 0 });
/** @nocollapse */
MonacoDiffEditorComponent.ctorParameters = () => [
    { type: MonacoEditorLoaderService }
];
MonacoDiffEditorComponent.propDecorators = {
    original: [{ type: Input }],
    modified: [{ type: Input }],
    options: [{ type: Input }],
    init: [{ type: Output }],
    editorContent: [{ type: ViewChild, args: ['diffEditor', { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MonacoDiffEditorComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-monaco-diff-editor',
                template: `<div #container materiaResized (resized)="onResized($event)" class="editor-container" fxFlex>
<div class="wrapper">
  <div
    #diffEditor
    class="monaco-editor"
    [style.width.px]="container.offsetWidth"
    [style.height.px]="container.offsetHeight" style="min-width: 0;"
  ></div>
</div>
</div>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`:host {
flex: 1;
box-sizing: border-box;
flex-direction: column;
display: flex;
overflow: hidden;
max-width: 100%;
min-wdith: 0;
}
.wrapper {
width: 0px; height: 0px;
}
.editor-container {
text-overflow: ellipsis;
overflow: hidden;
position: relative;
min-width: 0;
display: table;
width: 100%;
height: 100%;
}`]
            }]
    }], function () { return [{ type: MonacoEditorLoaderService }]; }, { init: [{
            type: Output
        }], original: [{
            type: Input
        }], modified: [{
            type: Input
        }], options: [{
            type: Input
        }], editorContent: [{
            type: ViewChild,
            args: ['diffEditor', { static: true }]
        }] }); })();
if (false) {
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.container;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.editor;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.original;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.modified;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.options;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.init;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.editorContent;
    /**
     * @type {?}
     * @private
     */
    MonacoDiffEditorComponent.prototype.monacoLoader;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/monaco-editor.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MonacoEditorModule {
}
MonacoEditorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MonacoEditorModule });
MonacoEditorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MonacoEditorModule_Factory(t) { return new (t || MonacoEditorModule)(); }, imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MonacoEditorModule, { declarations: [MonacoEditorLoaderDirective, MonacoEditorComponent, ResizedDirective, MonacoDiffEditorComponent], exports: [MonacoEditorLoaderDirective, MonacoEditorComponent, MonacoDiffEditorComponent, ResizedDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MonacoEditorModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [
                    MonacoEditorLoaderDirective,
                    MonacoEditorComponent,
                    ResizedDirective,
                    MonacoDiffEditorComponent
                ],
                exports: [
                    MonacoEditorLoaderDirective,
                    MonacoEditorComponent,
                    MonacoDiffEditorComponent,
                    ResizedDirective
                ],
                entryComponents: [MonacoEditorComponent, MonacoDiffEditorComponent]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: materia-ui-ngx-monaco-editor.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MONACO_PATH, MonacoDiffEditorComponent, MonacoEditorComponent, MonacoEditorLoaderDirective, MonacoEditorLoaderService, MonacoEditorModule, ResizedDirective, ResizedEvent };

//# sourceMappingURL=materia-ui-ngx-monaco-editor.js.map