(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('css-element-queries'), require('rxjs'), require('rxjs/operators'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@materia-ui/ngx-monaco-editor', ['exports', '@angular/core', 'css-element-queries', 'rxjs', 'rxjs/operators', '@angular/forms'], factory) :
    (global = global || self, factory((global['materia-ui'] = global['materia-ui'] || {}, global['materia-ui']['ngx-monaco-editor'] = {}), global.ng.core, global.cssElementQueries, global.rxjs, global.rxjs.operators, global.ng.forms));
}(this, (function (exports, core, cssElementQueries, rxjs, operators, forms) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/resized-event.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ResizedEvent = /** @class */ (function () {
        function ResizedEvent(element, newWidth, newHeight, oldWidth, oldHeight) {
            this.element = element;
            this.newWidth = newWidth;
            this.newHeight = newHeight;
            this.oldWidth = oldWidth;
            this.oldHeight = oldHeight;
        }
        return ResizedEvent;
    }());
    if (false) {
        /** @type {?} */
        ResizedEvent.prototype.element;
        /** @type {?} */
        ResizedEvent.prototype.newWidth;
        /** @type {?} */
        ResizedEvent.prototype.newHeight;
        /** @type {?} */
        ResizedEvent.prototype.oldWidth;
        /** @type {?} */
        ResizedEvent.prototype.oldHeight;
    }
    var ResizedDirective = /** @class */ (function () {
        function ResizedDirective(element) {
            this.element = element;
            this.resized = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        ResizedDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.resizeEvent = new cssElementQueries.ResizeSensor(this.element.nativeElement, (/**
             * @param {?} x
             * @return {?}
             */
            function (x) { return _this.onResized(); }));
            this.onResized();
        };
        /**
         * @private
         * @return {?}
         */
        ResizedDirective.prototype.onResized = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var newWidth = this.element.nativeElement.clientWidth;
            /** @type {?} */
            var newHeight = this.element.nativeElement.clientHeight;
            if (newWidth === this.oldWidth && newHeight === this.oldHeight) {
                return;
            }
            /** @type {?} */
            var event = new ResizedEvent(this.element, newWidth, newHeight, this.oldWidth, this.oldHeight);
            this.oldWidth = this.element.nativeElement.clientWidth;
            this.oldHeight = this.element.nativeElement.clientHeight;
            this.resized.next(event);
        };
        ResizedDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[materiaResized]',
                        exportAs: 'materiaResized'
                    },] }
        ];
        /** @nocollapse */
        ResizedDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        ResizedDirective.propDecorators = {
            resized: [{ type: core.Output }]
        };
        return ResizedDirective;
    }());
    if (false) {
        /** @type {?} */
        ResizedDirective.prototype.resized;
        /**
         * @type {?}
         * @private
         */
        ResizedDirective.prototype.oldWidth;
        /**
         * @type {?}
         * @private
         */
        ResizedDirective.prototype.oldHeight;
        /**
         * @type {?}
         * @private
         */
        ResizedDirective.prototype.resizeEvent;
        /**
         * @type {?}
         * @private
         */
        ResizedDirective.prototype.element;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/interfaces/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /// <reference path="monaco.d.ts" />
    /** @type {?} */
    var MONACO_PATH = 'MONACO_PATH';

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/services/monaco-editor-loader.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MonacoEditorLoaderService = /** @class */ (function () {
        function MonacoEditorLoaderService(ngZone, monacoPathConfig) {
            var _this = this;
            this.ngZone = ngZone;
            this.monacoPathConfig = monacoPathConfig;
            this.isMonacoLoaded$ = new rxjs.BehaviorSubject(false);
            this._monacoPath = 'assets/monaco-editor/min/vs';
            if (((/** @type {?} */ (window))).monacoEditorAlreadyInitialized) {
                ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this.isMonacoLoaded$.next(true); }));
                return;
            }
            ((/** @type {?} */ (window))).monacoEditorAlreadyInitialized = true;
            if (this.monacoPathConfig) {
                this.monacoPath = this.monacoPathConfig;
            }
            this.loadMonaco();
        }
        Object.defineProperty(MonacoEditorLoaderService.prototype, "monacoPath", {
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value) {
                    this._monacoPath = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MonacoEditorLoaderService.prototype.loadMonaco = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var onGotAmdLoader = (/**
             * @return {?}
             */
            function () {
                // Load monaco
                ((/** @type {?} */ (window))).amdRequire = ((/** @type {?} */ (window))).require;
                if (_this.nodeRequire) {
                    ((/** @type {?} */ (window))).require = _this.nodeRequire;
                }
                ((/** @type {?} */ (window))).amdRequire.config({ paths: { 'vs': _this._monacoPath } });
                ((/** @type {?} */ (window))).amdRequire(['vs/editor/editor.main'], (/**
                 * @return {?}
                 */
                function () {
                    _this.ngZone.run((/**
                     * @return {?}
                     */
                    function () { return _this.isMonacoLoaded$.next(true); }));
                }));
            });
            /** @type {?} */
            var loaderScript = null;
            // Load AMD loader if necessary
            if (!((/** @type {?} */ (window))).require && !((/** @type {?} */ (window))).amdRequire) {
                loaderScript = document.createElement('script');
                loaderScript.type = 'text/javascript';
                loaderScript.src = this._monacoPath + "/loader.js";
                loaderScript.addEventListener('load', onGotAmdLoader);
                document.body.appendChild(loaderScript);
            }
            else if (!((/** @type {?} */ (window))).amdRequire) {
                this.addElectronFixScripts();
                this.nodeRequire = ((/** @type {?} */ (window))).require;
                loaderScript = document.createElement('script');
                loaderScript.type = 'text/javascript';
                loaderScript.src = this._monacoPath + "/loader.js";
                loaderScript.addEventListener('load', onGotAmdLoader);
                document.body.appendChild(loaderScript);
            }
            else {
                onGotAmdLoader();
            }
        };
        /**
         * @return {?}
         */
        MonacoEditorLoaderService.prototype.addElectronFixScripts = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var electronFixScript = document.createElement('script');
            // workaround monaco-css not understanding the environment
            /** @type {?} */
            var inlineScript = document.createTextNode('self.module = undefined;');
            // workaround monaco-typescript not understanding the environment
            /** @type {?} */
            var inlineScript2 = document.createTextNode('self.process.browser = true;');
            electronFixScript.appendChild(inlineScript);
            electronFixScript.appendChild(inlineScript2);
            document.body.appendChild(electronFixScript);
        };
        MonacoEditorLoaderService.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        MonacoEditorLoaderService.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MONACO_PATH,] }] }
        ]; };
        /** @nocollapse */ MonacoEditorLoaderService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function MonacoEditorLoaderService_Factory() { return new MonacoEditorLoaderService(core.ɵɵinject(core.NgZone), core.ɵɵinject("MONACO_PATH", 8)); }, token: MonacoEditorLoaderService, providedIn: "root" });
        return MonacoEditorLoaderService;
    }());
    if (false) {
        /** @type {?} */
        MonacoEditorLoaderService.prototype.nodeRequire;
        /** @type {?} */
        MonacoEditorLoaderService.prototype.isMonacoLoaded$;
        /**
         * @type {?}
         * @private
         */
        MonacoEditorLoaderService.prototype._monacoPath;
        /**
         * @type {?}
         * @private
         */
        MonacoEditorLoaderService.prototype.ngZone;
        /** @type {?} */
        MonacoEditorLoaderService.prototype.monacoPathConfig;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/monaco-editor-loader.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MonacoEditorLoaderDirective = /** @class */ (function () {
        function MonacoEditorLoaderDirective(templateRef, viewContainer, monacoEditorLoaderService) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.monacoEditorLoaderService = monacoEditorLoaderService;
            this.isMonacoLoaded$ = this.monacoEditorLoaderService.isMonacoLoaded$.asObservable();
            this.destroyed$ = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        MonacoEditorLoaderDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.isMonacoLoaded$.pipe(operators.takeUntil(this.destroyed$)).subscribe((/**
             * @param {?} loaded
             * @return {?}
             */
            function (loaded) {
                if (!loaded) {
                    return _this.viewContainer.clear();
                }
                _this.viewContainer.createEmbeddedView(_this.templateRef);
            }));
        };
        /**
         * @return {?}
         */
        MonacoEditorLoaderDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.destroyed$.next();
            this.destroyed$.complete();
        };
        MonacoEditorLoaderDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[ngxLoadMonacoEditor]' },] }
        ];
        /** @nocollapse */
        MonacoEditorLoaderDirective.ctorParameters = function () { return [
            { type: core.TemplateRef },
            { type: core.ViewContainerRef },
            { type: MonacoEditorLoaderService }
        ]; };
        return MonacoEditorLoaderDirective;
    }());
    if (false) {
        /** @type {?} */
        MonacoEditorLoaderDirective.prototype.isMonacoLoaded$;
        /** @type {?} */
        MonacoEditorLoaderDirective.prototype.destroyed$;
        /**
         * @type {?}
         * @private
         */
        MonacoEditorLoaderDirective.prototype.templateRef;
        /**
         * @type {?}
         * @private
         */
        MonacoEditorLoaderDirective.prototype.viewContainer;
        /**
         * @type {?}
         * @private
         */
        MonacoEditorLoaderDirective.prototype.monacoEditorLoaderService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/monaco-editor/monaco-editor.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MonacoEditorComponent = /** @class */ (function () {
        function MonacoEditorComponent(monacoLoader) {
            this.monacoLoader = monacoLoader;
            this.init = new core.EventEmitter();
            this.propagateChange = (/**
             * @param {?} _
             * @return {?}
             */
            function (_) { });
        }
        /**
         * @return {?}
         */
        MonacoEditorComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.container = this.editorContent.nativeElement;
            this.monacoLoader.isMonacoLoaded$.pipe(operators.filter((/**
             * @param {?} isLoaded
             * @return {?}
             */
            function (isLoaded) { return isLoaded; })), operators.take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                _this.initMonaco();
            }));
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        MonacoEditorComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (this.editor && changes.options && !changes.options.firstChange) {
                if (changes.options.previousValue.language !== changes.options.currentValue.language) {
                    monaco.editor.setModelLanguage(this.editor.getModel(), this.options && this.options.language ? this.options.language : 'text');
                }
                if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                    monaco.editor.setTheme(changes.options.currentValue.theme);
                }
                this.editor.updateOptions(changes.options.currentValue);
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MonacoEditorComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.value = value;
            if (this.editor && value) {
                this.editor.setValue(value);
            }
            else if (this.editor) {
                this.editor.setValue('');
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MonacoEditorComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.propagateChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MonacoEditorComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouched = fn;
        };
        /**
         * @return {?}
         */
        MonacoEditorComponent.prototype.validate = /**
         * @return {?}
         */
        function () {
            return (!this.parseError) ? null : {
                parseError: {
                    valid: false,
                }
            };
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MonacoEditorComponent.prototype.registerOnValidatorChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onErrorStatusChange = fn;
        };
        /**
         * @private
         * @return {?}
         */
        MonacoEditorComponent.prototype.initMonaco = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var opts = {
                value: [this.value].join('\n'),
                language: 'text',
                automaticLayout: true,
                scrollBeyondLastLine: false,
                theme: 'vc'
            };
            if (this.options) {
                opts = Object.assign({}, opts, this.options);
            }
            this.editor = monaco.editor.create(this.container, opts);
            this.editor.layout();
            this.editor.onDidChangeModelContent((/**
             * @return {?}
             */
            function () {
                _this.propagateChange(_this.editor.getValue());
            }));
            this.editor.onDidChangeModelDecorations((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var pastParseError = _this.parseError;
                if (monaco.editor.getModelMarkers({}).map((/**
                 * @param {?} m
                 * @return {?}
                 */
                function (m) { return m.message; })).join(', ')) {
                    _this.parseError = true;
                }
                else {
                    _this.parseError = false;
                }
                if (pastParseError !== _this.parseError) {
                    _this.onErrorStatusChange();
                }
            }));
            this.editor.onDidBlurEditorText((/**
             * @return {?}
             */
            function () {
                _this.onTouched();
            }));
            this.init.emit(this.editor);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MonacoEditorComponent.prototype.onResized = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.editor) {
                this.editor.layout({
                    width: event.newWidth,
                    height: event.newHeight
                });
            }
        };
        /**
         * @return {?}
         */
        MonacoEditorComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.editor) {
                this.editor.dispose();
            }
        };
        MonacoEditorComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-monaco-editor',
                        template: "<div #container materiaResized (resized)=\"onResized($event)\" class=\"editor-container\" fxFlex>\n\t<div class=\"wrapper\">\n\t\t<div\n\t\t\t#editor\n\t\t\tclass=\"monaco-editor\"\n\t\t\t[style.width.px]=\"container.offsetWidth\"\n\t\t\t[style.height.px]=\"container.offsetHeight\" style=\"min-width: 0;\"\n\t\t></div>\n\t</div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return MonacoEditorComponent; })),
                                multi: true
                            },
                            {
                                provide: forms.NG_VALIDATORS,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return MonacoEditorComponent; })),
                                multi: true,
                            }
                        ],
                        styles: [":host {\n\tflex: 1;\n\tbox-sizing: border-box;\n\tflex-direction: column;\n\tdisplay: flex;\n\toverflow: hidden;\n\tmax-width: 100%;\n\tmin-wdith: 0;\n}\n.wrapper {\n\twidth: 0px; height: 0px;\n}\n.editor-container {\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n\tposition: relative;\n\tmin-width: 0;\n\tdisplay: table;\n\twidth: 100%;\n\theight: 100%;\n}"]
                    }] }
        ];
        /** @nocollapse */
        MonacoEditorComponent.ctorParameters = function () { return [
            { type: MonacoEditorLoaderService }
        ]; };
        MonacoEditorComponent.propDecorators = {
            options: [{ type: core.Input }],
            init: [{ type: core.Output }],
            editorContent: [{ type: core.ViewChild, args: ['editor', { static: true },] }]
        };
        return MonacoEditorComponent;
    }());
    if (false) {
        /** @type {?} */
        MonacoEditorComponent.prototype.options;
        /** @type {?} */
        MonacoEditorComponent.prototype.init;
        /** @type {?} */
        MonacoEditorComponent.prototype.editorContent;
        /** @type {?} */
        MonacoEditorComponent.prototype.container;
        /** @type {?} */
        MonacoEditorComponent.prototype.editor;
        /** @type {?} */
        MonacoEditorComponent.prototype.value;
        /** @type {?} */
        MonacoEditorComponent.prototype.parseError;
        /**
         * @type {?}
         * @private
         */
        MonacoEditorComponent.prototype.onTouched;
        /**
         * @type {?}
         * @private
         */
        MonacoEditorComponent.prototype.onErrorStatusChange;
        /**
         * @type {?}
         * @private
         */
        MonacoEditorComponent.prototype.propagateChange;
        /**
         * @type {?}
         * @private
         */
        MonacoEditorComponent.prototype.monacoLoader;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/monaco-diff-editor/monaco-diff-editor.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MonacoDiffEditorComponent = /** @class */ (function () {
        function MonacoDiffEditorComponent(monacoLoader) {
            this.monacoLoader = monacoLoader;
            this.init = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        MonacoDiffEditorComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.container = this.editorContent.nativeElement;
            this.monacoLoader.isMonacoLoaded$.pipe(operators.filter((/**
             * @param {?} isLoaded
             * @return {?}
             */
            function (isLoaded) { return isLoaded; })), operators.take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                _this.initMonaco();
            }));
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        MonacoDiffEditorComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (this.editor && ((changes.code && !changes.code.firstChange) || (changes.modified && !changes.modified.firstChange))) {
                /** @type {?} */
                var modified = monaco.editor.createModel(this.modified);
                /** @type {?} */
                var original = monaco.editor.createModel(this.original);
                this.editor.setModel({
                    original: original,
                    modified: modified
                });
            }
            if (this.editor &&
                changes.options &&
                !changes.options.firstChange) {
                if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                    monaco.editor.setTheme(changes.options.currentValue.theme);
                }
                this.editor.updateOptions(changes.options.currentValue);
            }
        };
        /**
         * @private
         * @return {?}
         */
        MonacoDiffEditorComponent.prototype.initMonaco = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var opts = {
                readOnly: true,
                theme: 'vc'
            };
            if (this.options) {
                opts = Object.assign({}, opts, this.options);
            }
            this.editor = monaco.editor.createDiffEditor(this.container, opts);
            /** @type {?} */
            var original = monaco.editor.createModel(this.original);
            /** @type {?} */
            var modified = monaco.editor.createModel(this.modified);
            this.editor.setModel({
                original: original,
                modified: modified
            });
            this.editor.layout();
            this.init.emit(this.editor);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MonacoDiffEditorComponent.prototype.onResized = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.editor) {
                this.editor.layout({
                    width: event.newWidth,
                    height: event.newHeight
                });
            }
        };
        /**
         * @return {?}
         */
        MonacoDiffEditorComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.editor) {
                this.editor.dispose();
            }
        };
        MonacoDiffEditorComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-monaco-diff-editor',
                        template: "<div #container materiaResized (resized)=\"onResized($event)\" class=\"editor-container\" fxFlex>\n<div class=\"wrapper\">\n  <div\n    #diffEditor\n    class=\"monaco-editor\"\n    [style.width.px]=\"container.offsetWidth\"\n    [style.height.px]=\"container.offsetHeight\" style=\"min-width: 0;\"\n  ></div>\n</div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [":host {\nflex: 1;\nbox-sizing: border-box;\nflex-direction: column;\ndisplay: flex;\noverflow: hidden;\nmax-width: 100%;\nmin-wdith: 0;\n}\n.wrapper {\nwidth: 0px; height: 0px;\n}\n.editor-container {\ntext-overflow: ellipsis;\noverflow: hidden;\nposition: relative;\nmin-width: 0;\ndisplay: table;\nwidth: 100%;\nheight: 100%;\n}"]
                    }] }
        ];
        /** @nocollapse */
        MonacoDiffEditorComponent.ctorParameters = function () { return [
            { type: MonacoEditorLoaderService }
        ]; };
        MonacoDiffEditorComponent.propDecorators = {
            original: [{ type: core.Input }],
            modified: [{ type: core.Input }],
            options: [{ type: core.Input }],
            init: [{ type: core.Output }],
            editorContent: [{ type: core.ViewChild, args: ['diffEditor', { static: true },] }]
        };
        return MonacoDiffEditorComponent;
    }());
    if (false) {
        /** @type {?} */
        MonacoDiffEditorComponent.prototype.container;
        /** @type {?} */
        MonacoDiffEditorComponent.prototype.editor;
        /** @type {?} */
        MonacoDiffEditorComponent.prototype.original;
        /** @type {?} */
        MonacoDiffEditorComponent.prototype.modified;
        /** @type {?} */
        MonacoDiffEditorComponent.prototype.options;
        /** @type {?} */
        MonacoDiffEditorComponent.prototype.init;
        /** @type {?} */
        MonacoDiffEditorComponent.prototype.editorContent;
        /**
         * @type {?}
         * @private
         */
        MonacoDiffEditorComponent.prototype.monacoLoader;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/monaco-editor.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MonacoEditorModule = /** @class */ (function () {
        function MonacoEditorModule() {
        }
        MonacoEditorModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        declarations: [
                            MonacoEditorLoaderDirective,
                            MonacoEditorComponent,
                            ResizedDirective,
                            MonacoDiffEditorComponent
                        ],
                        exports: [
                            MonacoEditorLoaderDirective,
                            MonacoEditorComponent,
                            MonacoDiffEditorComponent,
                            ResizedDirective
                        ],
                        entryComponents: [MonacoEditorComponent, MonacoDiffEditorComponent]
                    },] }
        ];
        return MonacoEditorModule;
    }());

    exports.MONACO_PATH = MONACO_PATH;
    exports.MonacoDiffEditorComponent = MonacoDiffEditorComponent;
    exports.MonacoEditorComponent = MonacoEditorComponent;
    exports.MonacoEditorLoaderDirective = MonacoEditorLoaderDirective;
    exports.MonacoEditorLoaderService = MonacoEditorLoaderService;
    exports.MonacoEditorModule = MonacoEditorModule;
    exports.ResizedDirective = ResizedDirective;
    exports.ResizedEvent = ResizedEvent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=materia-ui-ngx-monaco-editor.umd.js.map
