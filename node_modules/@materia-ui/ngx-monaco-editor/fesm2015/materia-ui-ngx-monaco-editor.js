import { EventEmitter, Directive, ElementRef, Output, Injectable, NgZone, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, TemplateRef, ViewContainerRef, Component, ChangeDetectionStrategy, forwardRef, Input, ViewChild, NgModule } from '@angular/core';
import { ResizeSensor } from 'css-element-queries';
import { BehaviorSubject, Subject } from 'rxjs';
import { takeUntil, filter, take } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/resized-event.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ResizedEvent {
    /**
     * @param {?} element
     * @param {?} newWidth
     * @param {?} newHeight
     * @param {?} oldWidth
     * @param {?} oldHeight
     */
    constructor(element, newWidth, newHeight, oldWidth, oldHeight) {
        this.element = element;
        this.newWidth = newWidth;
        this.newHeight = newHeight;
        this.oldWidth = oldWidth;
        this.oldHeight = oldHeight;
    }
}
if (false) {
    /** @type {?} */
    ResizedEvent.prototype.element;
    /** @type {?} */
    ResizedEvent.prototype.newWidth;
    /** @type {?} */
    ResizedEvent.prototype.newHeight;
    /** @type {?} */
    ResizedEvent.prototype.oldWidth;
    /** @type {?} */
    ResizedEvent.prototype.oldHeight;
}
class ResizedDirective {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.resized = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.resizeEvent = new ResizeSensor(this.element.nativeElement, (/**
         * @param {?} x
         * @return {?}
         */
        x => this.onResized()));
        this.onResized();
    }
    /**
     * @private
     * @return {?}
     */
    onResized() {
        /** @type {?} */
        const newWidth = this.element.nativeElement.clientWidth;
        /** @type {?} */
        const newHeight = this.element.nativeElement.clientHeight;
        if (newWidth === this.oldWidth && newHeight === this.oldHeight) {
            return;
        }
        /** @type {?} */
        const event = new ResizedEvent(this.element, newWidth, newHeight, this.oldWidth, this.oldHeight);
        this.oldWidth = this.element.nativeElement.clientWidth;
        this.oldHeight = this.element.nativeElement.clientHeight;
        this.resized.next(event);
    }
}
ResizedDirective.decorators = [
    { type: Directive, args: [{
                selector: '[materiaResized]',
                exportAs: 'materiaResized'
            },] }
];
/** @nocollapse */
ResizedDirective.ctorParameters = () => [
    { type: ElementRef }
];
ResizedDirective.propDecorators = {
    resized: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    ResizedDirective.prototype.resized;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.oldWidth;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.oldHeight;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.resizeEvent;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.element;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/interfaces/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/// <reference path="monaco.d.ts" />
/** @type {?} */
const MONACO_PATH = 'MONACO_PATH';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/monaco-editor-loader.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MonacoEditorLoaderService {
    /**
     * @param {?} ngZone
     * @param {?} monacoPathConfig
     */
    constructor(ngZone, monacoPathConfig) {
        this.ngZone = ngZone;
        this.monacoPathConfig = monacoPathConfig;
        this.isMonacoLoaded$ = new BehaviorSubject(false);
        this._monacoPath = 'assets/monaco-editor/min/vs';
        if (((/** @type {?} */ (window))).monacoEditorAlreadyInitialized) {
            ngZone.run((/**
             * @return {?}
             */
            () => this.isMonacoLoaded$.next(true)));
            return;
        }
        ((/** @type {?} */ (window))).monacoEditorAlreadyInitialized = true;
        if (this.monacoPathConfig) {
            this.monacoPath = this.monacoPathConfig;
        }
        this.loadMonaco();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set monacoPath(value) {
        if (value) {
            this._monacoPath = value;
        }
    }
    /**
     * @return {?}
     */
    loadMonaco() {
        /** @type {?} */
        const onGotAmdLoader = (/**
         * @return {?}
         */
        () => {
            // Load monaco
            ((/** @type {?} */ (window))).amdRequire = ((/** @type {?} */ (window))).require;
            if (this.nodeRequire) {
                ((/** @type {?} */ (window))).require = this.nodeRequire;
            }
            ((/** @type {?} */ (window))).amdRequire.config({ paths: { 'vs': this._monacoPath } });
            ((/** @type {?} */ (window))).amdRequire(['vs/editor/editor.main'], (/**
             * @return {?}
             */
            () => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => this.isMonacoLoaded$.next(true)));
            }));
        });
        /** @type {?} */
        let loaderScript = null;
        // Load AMD loader if necessary
        if (!((/** @type {?} */ (window))).require && !((/** @type {?} */ (window))).amdRequire) {
            loaderScript = document.createElement('script');
            loaderScript.type = 'text/javascript';
            loaderScript.src = `${this._monacoPath}/loader.js`;
            loaderScript.addEventListener('load', onGotAmdLoader);
            document.body.appendChild(loaderScript);
        }
        else if (!((/** @type {?} */ (window))).amdRequire) {
            this.addElectronFixScripts();
            this.nodeRequire = ((/** @type {?} */ (window))).require;
            loaderScript = document.createElement('script');
            loaderScript.type = 'text/javascript';
            loaderScript.src = `${this._monacoPath}/loader.js`;
            loaderScript.addEventListener('load', onGotAmdLoader);
            document.body.appendChild(loaderScript);
        }
        else {
            onGotAmdLoader();
        }
    }
    /**
     * @return {?}
     */
    addElectronFixScripts() {
        /** @type {?} */
        const electronFixScript = document.createElement('script');
        // workaround monaco-css not understanding the environment
        /** @type {?} */
        const inlineScript = document.createTextNode('self.module = undefined;');
        // workaround monaco-typescript not understanding the environment
        /** @type {?} */
        const inlineScript2 = document.createTextNode('self.process.browser = true;');
        electronFixScript.appendChild(inlineScript);
        electronFixScript.appendChild(inlineScript2);
        document.body.appendChild(electronFixScript);
    }
}
MonacoEditorLoaderService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
MonacoEditorLoaderService.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MONACO_PATH,] }] }
];
/** @nocollapse */ MonacoEditorLoaderService.ngInjectableDef = ɵɵdefineInjectable({ factory: function MonacoEditorLoaderService_Factory() { return new MonacoEditorLoaderService(ɵɵinject(NgZone), ɵɵinject("MONACO_PATH", 8)); }, token: MonacoEditorLoaderService, providedIn: "root" });
if (false) {
    /** @type {?} */
    MonacoEditorLoaderService.prototype.nodeRequire;
    /** @type {?} */
    MonacoEditorLoaderService.prototype.isMonacoLoaded$;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderService.prototype._monacoPath;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderService.prototype.ngZone;
    /** @type {?} */
    MonacoEditorLoaderService.prototype.monacoPathConfig;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/monaco-editor-loader.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MonacoEditorLoaderDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     * @param {?} monacoEditorLoaderService
     */
    constructor(templateRef, viewContainer, monacoEditorLoaderService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.monacoEditorLoaderService = monacoEditorLoaderService;
        this.isMonacoLoaded$ = this.monacoEditorLoaderService.isMonacoLoaded$.asObservable();
        this.destroyed$ = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isMonacoLoaded$.pipe(takeUntil(this.destroyed$)).subscribe((/**
         * @param {?} loaded
         * @return {?}
         */
        (loaded) => {
            if (!loaded) {
                return this.viewContainer.clear();
            }
            this.viewContainer.createEmbeddedView(this.templateRef);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
}
MonacoEditorLoaderDirective.decorators = [
    { type: Directive, args: [{ selector: '[ngxLoadMonacoEditor]' },] }
];
/** @nocollapse */
MonacoEditorLoaderDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: MonacoEditorLoaderService }
];
if (false) {
    /** @type {?} */
    MonacoEditorLoaderDirective.prototype.isMonacoLoaded$;
    /** @type {?} */
    MonacoEditorLoaderDirective.prototype.destroyed$;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderDirective.prototype.monacoEditorLoaderService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/monaco-editor/monaco-editor.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MonacoEditorComponent {
    /**
     * @param {?} monacoLoader
     */
    constructor(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
        this.propagateChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.container = this.editorContent.nativeElement;
        this.monacoLoader.isMonacoLoaded$.pipe(filter((/**
         * @param {?} isLoaded
         * @return {?}
         */
        isLoaded => isLoaded)), take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            this.initMonaco();
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.editor && changes.options && !changes.options.firstChange) {
            if (changes.options.previousValue.language !== changes.options.currentValue.language) {
                monaco.editor.setModelLanguage(this.editor.getModel(), this.options && this.options.language ? this.options.language : 'text');
            }
            if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                monaco.editor.setTheme(changes.options.currentValue.theme);
            }
            this.editor.updateOptions(changes.options.currentValue);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
        if (this.editor && value) {
            this.editor.setValue(value);
        }
        else if (this.editor) {
            this.editor.setValue('');
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @return {?}
     */
    validate() {
        return (!this.parseError) ? null : {
            parseError: {
                valid: false,
            }
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onErrorStatusChange = fn;
    }
    /**
     * @private
     * @return {?}
     */
    initMonaco() {
        /** @type {?} */
        let opts = {
            value: [this.value].join('\n'),
            language: 'text',
            automaticLayout: true,
            scrollBeyondLastLine: false,
            theme: 'vc'
        };
        if (this.options) {
            opts = Object.assign({}, opts, this.options);
        }
        this.editor = monaco.editor.create(this.container, opts);
        this.editor.layout();
        this.editor.onDidChangeModelContent((/**
         * @return {?}
         */
        () => {
            this.propagateChange(this.editor.getValue());
        }));
        this.editor.onDidChangeModelDecorations((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const pastParseError = this.parseError;
            if (monaco.editor.getModelMarkers({}).map((/**
             * @param {?} m
             * @return {?}
             */
            m => m.message)).join(', ')) {
                this.parseError = true;
            }
            else {
                this.parseError = false;
            }
            if (pastParseError !== this.parseError) {
                this.onErrorStatusChange();
            }
        }));
        this.editor.onDidBlurEditorText((/**
         * @return {?}
         */
        () => {
            this.onTouched();
        }));
        this.init.emit(this.editor);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResized(event) {
        if (this.editor) {
            this.editor.layout({
                width: event.newWidth,
                height: event.newHeight
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.editor) {
            this.editor.dispose();
        }
    }
}
MonacoEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-monaco-editor',
                template: `<div #container materiaResized (resized)="onResized($event)" class="editor-container" fxFlex>
	<div class="wrapper">
		<div
			#editor
			class="monaco-editor"
			[style.width.px]="container.offsetWidth"
			[style.height.px]="container.offsetHeight" style="min-width: 0;"
		></div>
	</div>
</div>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => MonacoEditorComponent)),
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => MonacoEditorComponent)),
                        multi: true,
                    }
                ],
                styles: [`:host {
	flex: 1;
	box-sizing: border-box;
	flex-direction: column;
	display: flex;
	overflow: hidden;
	max-width: 100%;
	min-wdith: 0;
}
.wrapper {
	width: 0px; height: 0px;
}
.editor-container {
	text-overflow: ellipsis;
	overflow: hidden;
	position: relative;
	min-width: 0;
	display: table;
	width: 100%;
	height: 100%;
}`]
            }] }
];
/** @nocollapse */
MonacoEditorComponent.ctorParameters = () => [
    { type: MonacoEditorLoaderService }
];
MonacoEditorComponent.propDecorators = {
    options: [{ type: Input }],
    init: [{ type: Output }],
    editorContent: [{ type: ViewChild, args: ['editor', { static: true },] }]
};
if (false) {
    /** @type {?} */
    MonacoEditorComponent.prototype.options;
    /** @type {?} */
    MonacoEditorComponent.prototype.init;
    /** @type {?} */
    MonacoEditorComponent.prototype.editorContent;
    /** @type {?} */
    MonacoEditorComponent.prototype.container;
    /** @type {?} */
    MonacoEditorComponent.prototype.editor;
    /** @type {?} */
    MonacoEditorComponent.prototype.value;
    /** @type {?} */
    MonacoEditorComponent.prototype.parseError;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.onTouched;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.onErrorStatusChange;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.propagateChange;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.monacoLoader;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/monaco-diff-editor/monaco-diff-editor.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MonacoDiffEditorComponent {
    /**
     * @param {?} monacoLoader
     */
    constructor(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.container = this.editorContent.nativeElement;
        this.monacoLoader.isMonacoLoaded$.pipe(filter((/**
         * @param {?} isLoaded
         * @return {?}
         */
        isLoaded => isLoaded)), take(1)).subscribe((/**
         * @return {?}
         */
        () => {
            this.initMonaco();
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.editor && ((changes.code && !changes.code.firstChange) || (changes.modified && !changes.modified.firstChange))) {
            /** @type {?} */
            const modified = monaco.editor.createModel(this.modified);
            /** @type {?} */
            const original = monaco.editor.createModel(this.original);
            this.editor.setModel({
                original,
                modified
            });
        }
        if (this.editor &&
            changes.options &&
            !changes.options.firstChange) {
            if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                monaco.editor.setTheme(changes.options.currentValue.theme);
            }
            this.editor.updateOptions(changes.options.currentValue);
        }
    }
    /**
     * @private
     * @return {?}
     */
    initMonaco() {
        /** @type {?} */
        let opts = {
            readOnly: true,
            theme: 'vc'
        };
        if (this.options) {
            opts = Object.assign({}, opts, this.options);
        }
        this.editor = monaco.editor.createDiffEditor(this.container, opts);
        /** @type {?} */
        const original = monaco.editor.createModel(this.original);
        /** @type {?} */
        const modified = monaco.editor.createModel(this.modified);
        this.editor.setModel({
            original,
            modified
        });
        this.editor.layout();
        this.init.emit(this.editor);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResized(event) {
        if (this.editor) {
            this.editor.layout({
                width: event.newWidth,
                height: event.newHeight
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.editor) {
            this.editor.dispose();
        }
    }
}
MonacoDiffEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-monaco-diff-editor',
                template: `<div #container materiaResized (resized)="onResized($event)" class="editor-container" fxFlex>
<div class="wrapper">
  <div
    #diffEditor
    class="monaco-editor"
    [style.width.px]="container.offsetWidth"
    [style.height.px]="container.offsetHeight" style="min-width: 0;"
  ></div>
</div>
</div>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`:host {
flex: 1;
box-sizing: border-box;
flex-direction: column;
display: flex;
overflow: hidden;
max-width: 100%;
min-wdith: 0;
}
.wrapper {
width: 0px; height: 0px;
}
.editor-container {
text-overflow: ellipsis;
overflow: hidden;
position: relative;
min-width: 0;
display: table;
width: 100%;
height: 100%;
}`]
            }] }
];
/** @nocollapse */
MonacoDiffEditorComponent.ctorParameters = () => [
    { type: MonacoEditorLoaderService }
];
MonacoDiffEditorComponent.propDecorators = {
    original: [{ type: Input }],
    modified: [{ type: Input }],
    options: [{ type: Input }],
    init: [{ type: Output }],
    editorContent: [{ type: ViewChild, args: ['diffEditor', { static: true },] }]
};
if (false) {
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.container;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.editor;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.original;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.modified;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.options;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.init;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.editorContent;
    /**
     * @type {?}
     * @private
     */
    MonacoDiffEditorComponent.prototype.monacoLoader;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/monaco-editor.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MonacoEditorModule {
}
MonacoEditorModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [
                    MonacoEditorLoaderDirective,
                    MonacoEditorComponent,
                    ResizedDirective,
                    MonacoDiffEditorComponent
                ],
                exports: [
                    MonacoEditorLoaderDirective,
                    MonacoEditorComponent,
                    MonacoDiffEditorComponent,
                    ResizedDirective
                ],
                entryComponents: [MonacoEditorComponent, MonacoDiffEditorComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: materia-ui-ngx-monaco-editor.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MONACO_PATH, MonacoDiffEditorComponent, MonacoEditorComponent, MonacoEditorLoaderDirective, MonacoEditorLoaderService, MonacoEditorModule, ResizedDirective, ResizedEvent };
//# sourceMappingURL=materia-ui-ngx-monaco-editor.js.map
