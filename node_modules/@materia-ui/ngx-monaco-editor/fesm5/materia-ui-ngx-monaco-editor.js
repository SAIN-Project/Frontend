import { EventEmitter, Directive, ElementRef, Output, Injectable, NgZone, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, TemplateRef, ViewContainerRef, Component, ChangeDetectionStrategy, forwardRef, Input, ViewChild, NgModule } from '@angular/core';
import { ResizeSensor } from 'css-element-queries';
import { BehaviorSubject, Subject } from 'rxjs';
import { takeUntil, filter, take } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/resized-event.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ResizedEvent = /** @class */ (function () {
    function ResizedEvent(element, newWidth, newHeight, oldWidth, oldHeight) {
        this.element = element;
        this.newWidth = newWidth;
        this.newHeight = newHeight;
        this.oldWidth = oldWidth;
        this.oldHeight = oldHeight;
    }
    return ResizedEvent;
}());
if (false) {
    /** @type {?} */
    ResizedEvent.prototype.element;
    /** @type {?} */
    ResizedEvent.prototype.newWidth;
    /** @type {?} */
    ResizedEvent.prototype.newHeight;
    /** @type {?} */
    ResizedEvent.prototype.oldWidth;
    /** @type {?} */
    ResizedEvent.prototype.oldHeight;
}
var ResizedDirective = /** @class */ (function () {
    function ResizedDirective(element) {
        this.element = element;
        this.resized = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ResizedDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.resizeEvent = new ResizeSensor(this.element.nativeElement, (/**
         * @param {?} x
         * @return {?}
         */
        function (x) { return _this.onResized(); }));
        this.onResized();
    };
    /**
     * @private
     * @return {?}
     */
    ResizedDirective.prototype.onResized = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var newWidth = this.element.nativeElement.clientWidth;
        /** @type {?} */
        var newHeight = this.element.nativeElement.clientHeight;
        if (newWidth === this.oldWidth && newHeight === this.oldHeight) {
            return;
        }
        /** @type {?} */
        var event = new ResizedEvent(this.element, newWidth, newHeight, this.oldWidth, this.oldHeight);
        this.oldWidth = this.element.nativeElement.clientWidth;
        this.oldHeight = this.element.nativeElement.clientHeight;
        this.resized.next(event);
    };
    ResizedDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[materiaResized]',
                    exportAs: 'materiaResized'
                },] }
    ];
    /** @nocollapse */
    ResizedDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    ResizedDirective.propDecorators = {
        resized: [{ type: Output }]
    };
    return ResizedDirective;
}());
if (false) {
    /** @type {?} */
    ResizedDirective.prototype.resized;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.oldWidth;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.oldHeight;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.resizeEvent;
    /**
     * @type {?}
     * @private
     */
    ResizedDirective.prototype.element;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/interfaces/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/// <reference path="monaco.d.ts" />
/** @type {?} */
var MONACO_PATH = 'MONACO_PATH';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/monaco-editor-loader.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MonacoEditorLoaderService = /** @class */ (function () {
    function MonacoEditorLoaderService(ngZone, monacoPathConfig) {
        var _this = this;
        this.ngZone = ngZone;
        this.monacoPathConfig = monacoPathConfig;
        this.isMonacoLoaded$ = new BehaviorSubject(false);
        this._monacoPath = 'assets/monaco-editor/min/vs';
        if (((/** @type {?} */ (window))).monacoEditorAlreadyInitialized) {
            ngZone.run((/**
             * @return {?}
             */
            function () { return _this.isMonacoLoaded$.next(true); }));
            return;
        }
        ((/** @type {?} */ (window))).monacoEditorAlreadyInitialized = true;
        if (this.monacoPathConfig) {
            this.monacoPath = this.monacoPathConfig;
        }
        this.loadMonaco();
    }
    Object.defineProperty(MonacoEditorLoaderService.prototype, "monacoPath", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this._monacoPath = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MonacoEditorLoaderService.prototype.loadMonaco = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var onGotAmdLoader = (/**
         * @return {?}
         */
        function () {
            // Load monaco
            ((/** @type {?} */ (window))).amdRequire = ((/** @type {?} */ (window))).require;
            if (_this.nodeRequire) {
                ((/** @type {?} */ (window))).require = _this.nodeRequire;
            }
            ((/** @type {?} */ (window))).amdRequire.config({ paths: { 'vs': _this._monacoPath } });
            ((/** @type {?} */ (window))).amdRequire(['vs/editor/editor.main'], (/**
             * @return {?}
             */
            function () {
                _this.ngZone.run((/**
                 * @return {?}
                 */
                function () { return _this.isMonacoLoaded$.next(true); }));
            }));
        });
        /** @type {?} */
        var loaderScript = null;
        // Load AMD loader if necessary
        if (!((/** @type {?} */ (window))).require && !((/** @type {?} */ (window))).amdRequire) {
            loaderScript = document.createElement('script');
            loaderScript.type = 'text/javascript';
            loaderScript.src = this._monacoPath + "/loader.js";
            loaderScript.addEventListener('load', onGotAmdLoader);
            document.body.appendChild(loaderScript);
        }
        else if (!((/** @type {?} */ (window))).amdRequire) {
            this.addElectronFixScripts();
            this.nodeRequire = ((/** @type {?} */ (window))).require;
            loaderScript = document.createElement('script');
            loaderScript.type = 'text/javascript';
            loaderScript.src = this._monacoPath + "/loader.js";
            loaderScript.addEventListener('load', onGotAmdLoader);
            document.body.appendChild(loaderScript);
        }
        else {
            onGotAmdLoader();
        }
    };
    /**
     * @return {?}
     */
    MonacoEditorLoaderService.prototype.addElectronFixScripts = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var electronFixScript = document.createElement('script');
        // workaround monaco-css not understanding the environment
        /** @type {?} */
        var inlineScript = document.createTextNode('self.module = undefined;');
        // workaround monaco-typescript not understanding the environment
        /** @type {?} */
        var inlineScript2 = document.createTextNode('self.process.browser = true;');
        electronFixScript.appendChild(inlineScript);
        electronFixScript.appendChild(inlineScript2);
        document.body.appendChild(electronFixScript);
    };
    MonacoEditorLoaderService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    MonacoEditorLoaderService.ctorParameters = function () { return [
        { type: NgZone },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MONACO_PATH,] }] }
    ]; };
    /** @nocollapse */ MonacoEditorLoaderService.ngInjectableDef = ɵɵdefineInjectable({ factory: function MonacoEditorLoaderService_Factory() { return new MonacoEditorLoaderService(ɵɵinject(NgZone), ɵɵinject("MONACO_PATH", 8)); }, token: MonacoEditorLoaderService, providedIn: "root" });
    return MonacoEditorLoaderService;
}());
if (false) {
    /** @type {?} */
    MonacoEditorLoaderService.prototype.nodeRequire;
    /** @type {?} */
    MonacoEditorLoaderService.prototype.isMonacoLoaded$;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderService.prototype._monacoPath;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderService.prototype.ngZone;
    /** @type {?} */
    MonacoEditorLoaderService.prototype.monacoPathConfig;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/monaco-editor-loader.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MonacoEditorLoaderDirective = /** @class */ (function () {
    function MonacoEditorLoaderDirective(templateRef, viewContainer, monacoEditorLoaderService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.monacoEditorLoaderService = monacoEditorLoaderService;
        this.isMonacoLoaded$ = this.monacoEditorLoaderService.isMonacoLoaded$.asObservable();
        this.destroyed$ = new Subject();
    }
    /**
     * @return {?}
     */
    MonacoEditorLoaderDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.isMonacoLoaded$.pipe(takeUntil(this.destroyed$)).subscribe((/**
         * @param {?} loaded
         * @return {?}
         */
        function (loaded) {
            if (!loaded) {
                return _this.viewContainer.clear();
            }
            _this.viewContainer.createEmbeddedView(_this.templateRef);
        }));
    };
    /**
     * @return {?}
     */
    MonacoEditorLoaderDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroyed$.next();
        this.destroyed$.complete();
    };
    MonacoEditorLoaderDirective.decorators = [
        { type: Directive, args: [{ selector: '[ngxLoadMonacoEditor]' },] }
    ];
    /** @nocollapse */
    MonacoEditorLoaderDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: MonacoEditorLoaderService }
    ]; };
    return MonacoEditorLoaderDirective;
}());
if (false) {
    /** @type {?} */
    MonacoEditorLoaderDirective.prototype.isMonacoLoaded$;
    /** @type {?} */
    MonacoEditorLoaderDirective.prototype.destroyed$;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorLoaderDirective.prototype.monacoEditorLoaderService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/monaco-editor/monaco-editor.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MonacoEditorComponent = /** @class */ (function () {
    function MonacoEditorComponent(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
        this.propagateChange = (/**
         * @param {?} _
         * @return {?}
         */
        function (_) { });
    }
    /**
     * @return {?}
     */
    MonacoEditorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.container = this.editorContent.nativeElement;
        this.monacoLoader.isMonacoLoaded$.pipe(filter((/**
         * @param {?} isLoaded
         * @return {?}
         */
        function (isLoaded) { return isLoaded; })), take(1)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.initMonaco();
        }));
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    MonacoEditorComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.editor && changes.options && !changes.options.firstChange) {
            if (changes.options.previousValue.language !== changes.options.currentValue.language) {
                monaco.editor.setModelLanguage(this.editor.getModel(), this.options && this.options.language ? this.options.language : 'text');
            }
            if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                monaco.editor.setTheme(changes.options.currentValue.theme);
            }
            this.editor.updateOptions(changes.options.currentValue);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    MonacoEditorComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
        if (this.editor && value) {
            this.editor.setValue(value);
        }
        else if (this.editor) {
            this.editor.setValue('');
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    MonacoEditorComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.propagateChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    MonacoEditorComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /**
     * @return {?}
     */
    MonacoEditorComponent.prototype.validate = /**
     * @return {?}
     */
    function () {
        return (!this.parseError) ? null : {
            parseError: {
                valid: false,
            }
        };
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    MonacoEditorComponent.prototype.registerOnValidatorChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onErrorStatusChange = fn;
    };
    /**
     * @private
     * @return {?}
     */
    MonacoEditorComponent.prototype.initMonaco = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var opts = {
            value: [this.value].join('\n'),
            language: 'text',
            automaticLayout: true,
            scrollBeyondLastLine: false,
            theme: 'vc'
        };
        if (this.options) {
            opts = Object.assign({}, opts, this.options);
        }
        this.editor = monaco.editor.create(this.container, opts);
        this.editor.layout();
        this.editor.onDidChangeModelContent((/**
         * @return {?}
         */
        function () {
            _this.propagateChange(_this.editor.getValue());
        }));
        this.editor.onDidChangeModelDecorations((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var pastParseError = _this.parseError;
            if (monaco.editor.getModelMarkers({}).map((/**
             * @param {?} m
             * @return {?}
             */
            function (m) { return m.message; })).join(', ')) {
                _this.parseError = true;
            }
            else {
                _this.parseError = false;
            }
            if (pastParseError !== _this.parseError) {
                _this.onErrorStatusChange();
            }
        }));
        this.editor.onDidBlurEditorText((/**
         * @return {?}
         */
        function () {
            _this.onTouched();
        }));
        this.init.emit(this.editor);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MonacoEditorComponent.prototype.onResized = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.editor) {
            this.editor.layout({
                width: event.newWidth,
                height: event.newHeight
            });
        }
    };
    /**
     * @return {?}
     */
    MonacoEditorComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.editor) {
            this.editor.dispose();
        }
    };
    MonacoEditorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-monaco-editor',
                    template: "<div #container materiaResized (resized)=\"onResized($event)\" class=\"editor-container\" fxFlex>\n\t<div class=\"wrapper\">\n\t\t<div\n\t\t\t#editor\n\t\t\tclass=\"monaco-editor\"\n\t\t\t[style.width.px]=\"container.offsetWidth\"\n\t\t\t[style.height.px]=\"container.offsetHeight\" style=\"min-width: 0;\"\n\t\t></div>\n\t</div>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return MonacoEditorComponent; })),
                            multi: true
                        },
                        {
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return MonacoEditorComponent; })),
                            multi: true,
                        }
                    ],
                    styles: [":host {\n\tflex: 1;\n\tbox-sizing: border-box;\n\tflex-direction: column;\n\tdisplay: flex;\n\toverflow: hidden;\n\tmax-width: 100%;\n\tmin-wdith: 0;\n}\n.wrapper {\n\twidth: 0px; height: 0px;\n}\n.editor-container {\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n\tposition: relative;\n\tmin-width: 0;\n\tdisplay: table;\n\twidth: 100%;\n\theight: 100%;\n}"]
                }] }
    ];
    /** @nocollapse */
    MonacoEditorComponent.ctorParameters = function () { return [
        { type: MonacoEditorLoaderService }
    ]; };
    MonacoEditorComponent.propDecorators = {
        options: [{ type: Input }],
        init: [{ type: Output }],
        editorContent: [{ type: ViewChild, args: ['editor', { static: true },] }]
    };
    return MonacoEditorComponent;
}());
if (false) {
    /** @type {?} */
    MonacoEditorComponent.prototype.options;
    /** @type {?} */
    MonacoEditorComponent.prototype.init;
    /** @type {?} */
    MonacoEditorComponent.prototype.editorContent;
    /** @type {?} */
    MonacoEditorComponent.prototype.container;
    /** @type {?} */
    MonacoEditorComponent.prototype.editor;
    /** @type {?} */
    MonacoEditorComponent.prototype.value;
    /** @type {?} */
    MonacoEditorComponent.prototype.parseError;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.onTouched;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.onErrorStatusChange;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.propagateChange;
    /**
     * @type {?}
     * @private
     */
    MonacoEditorComponent.prototype.monacoLoader;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/monaco-diff-editor/monaco-diff-editor.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MonacoDiffEditorComponent = /** @class */ (function () {
    function MonacoDiffEditorComponent(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
    }
    /**
     * @return {?}
     */
    MonacoDiffEditorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.container = this.editorContent.nativeElement;
        this.monacoLoader.isMonacoLoaded$.pipe(filter((/**
         * @param {?} isLoaded
         * @return {?}
         */
        function (isLoaded) { return isLoaded; })), take(1)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.initMonaco();
        }));
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    MonacoDiffEditorComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.editor && ((changes.code && !changes.code.firstChange) || (changes.modified && !changes.modified.firstChange))) {
            /** @type {?} */
            var modified = monaco.editor.createModel(this.modified);
            /** @type {?} */
            var original = monaco.editor.createModel(this.original);
            this.editor.setModel({
                original: original,
                modified: modified
            });
        }
        if (this.editor &&
            changes.options &&
            !changes.options.firstChange) {
            if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                monaco.editor.setTheme(changes.options.currentValue.theme);
            }
            this.editor.updateOptions(changes.options.currentValue);
        }
    };
    /**
     * @private
     * @return {?}
     */
    MonacoDiffEditorComponent.prototype.initMonaco = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var opts = {
            readOnly: true,
            theme: 'vc'
        };
        if (this.options) {
            opts = Object.assign({}, opts, this.options);
        }
        this.editor = monaco.editor.createDiffEditor(this.container, opts);
        /** @type {?} */
        var original = monaco.editor.createModel(this.original);
        /** @type {?} */
        var modified = monaco.editor.createModel(this.modified);
        this.editor.setModel({
            original: original,
            modified: modified
        });
        this.editor.layout();
        this.init.emit(this.editor);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MonacoDiffEditorComponent.prototype.onResized = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.editor) {
            this.editor.layout({
                width: event.newWidth,
                height: event.newHeight
            });
        }
    };
    /**
     * @return {?}
     */
    MonacoDiffEditorComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.editor) {
            this.editor.dispose();
        }
    };
    MonacoDiffEditorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-monaco-diff-editor',
                    template: "<div #container materiaResized (resized)=\"onResized($event)\" class=\"editor-container\" fxFlex>\n<div class=\"wrapper\">\n  <div\n    #diffEditor\n    class=\"monaco-editor\"\n    [style.width.px]=\"container.offsetWidth\"\n    [style.height.px]=\"container.offsetHeight\" style=\"min-width: 0;\"\n  ></div>\n</div>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [":host {\nflex: 1;\nbox-sizing: border-box;\nflex-direction: column;\ndisplay: flex;\noverflow: hidden;\nmax-width: 100%;\nmin-wdith: 0;\n}\n.wrapper {\nwidth: 0px; height: 0px;\n}\n.editor-container {\ntext-overflow: ellipsis;\noverflow: hidden;\nposition: relative;\nmin-width: 0;\ndisplay: table;\nwidth: 100%;\nheight: 100%;\n}"]
                }] }
    ];
    /** @nocollapse */
    MonacoDiffEditorComponent.ctorParameters = function () { return [
        { type: MonacoEditorLoaderService }
    ]; };
    MonacoDiffEditorComponent.propDecorators = {
        original: [{ type: Input }],
        modified: [{ type: Input }],
        options: [{ type: Input }],
        init: [{ type: Output }],
        editorContent: [{ type: ViewChild, args: ['diffEditor', { static: true },] }]
    };
    return MonacoDiffEditorComponent;
}());
if (false) {
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.container;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.editor;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.original;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.modified;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.options;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.init;
    /** @type {?} */
    MonacoDiffEditorComponent.prototype.editorContent;
    /**
     * @type {?}
     * @private
     */
    MonacoDiffEditorComponent.prototype.monacoLoader;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/monaco-editor.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MonacoEditorModule = /** @class */ (function () {
    function MonacoEditorModule() {
    }
    MonacoEditorModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    declarations: [
                        MonacoEditorLoaderDirective,
                        MonacoEditorComponent,
                        ResizedDirective,
                        MonacoDiffEditorComponent
                    ],
                    exports: [
                        MonacoEditorLoaderDirective,
                        MonacoEditorComponent,
                        MonacoDiffEditorComponent,
                        ResizedDirective
                    ],
                    entryComponents: [MonacoEditorComponent, MonacoDiffEditorComponent]
                },] }
    ];
    return MonacoEditorModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: materia-ui-ngx-monaco-editor.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MONACO_PATH, MonacoDiffEditorComponent, MonacoEditorComponent, MonacoEditorLoaderDirective, MonacoEditorLoaderService, MonacoEditorModule, ResizedDirective, ResizedEvent };
//# sourceMappingURL=materia-ui-ngx-monaco-editor.js.map
